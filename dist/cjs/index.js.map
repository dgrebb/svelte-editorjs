{"version":3,"file":"index.js","sources":["../../node_modules/svelte/src/runtime/internal/utils.js","../../node_modules/svelte/src/runtime/store/index.js","../../src/index.ts"],"sourcesContent":["/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n","import {\n\trun_all,\n\tsubscribe,\n\tnoop,\n\tsafe_not_equal,\n\tis_function,\n\tget_store_value\n} from '../internal/index.js';\n\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {import('./public.js').Unsubscriber} */\n\tlet stop;\n\t/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\t/** @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {import('./public.js').Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(value));\n\t}\n\n\t/**\n\t * @param {import('./public.js').Subscriber<T>} run\n\t * @param {import('./private.js').Invalidator<T>} [invalidate]\n\t * @returns {import('./public.js').Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(value);\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * @template {import('./private.js').Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<import('./public.js').Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = is_function(result) ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * https://svelte.dev/docs/svelte-store#readonly\n * @template T\n * @param {import('./public.js').Readable<T>} store  - store to make readonly\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\nexport { get_store_value as get };\n","import type EditorJS from '@editorjs/editorjs';\nimport type { EditorConfig, OutputData } from '@editorjs/editorjs';\nimport { writable } from 'svelte/store';\nimport type { Readable, Writable } from 'svelte/store';\n\nexport type EditorStore = {\n  instance?: EditorJS;\n  save?: () => void;\n  render?: (data: OutputData) => void;\n  clear?: () => void;\n};\n\nexport type EditorStoreAction = ((\n  node: HTMLElement,\n  parameters?: EditorConfig\n) => {\n  destroy?: () => void;\n}) &\n  Readable<EditorStore>;\n\nexport type EditorResponse = {\n  editor: EditorStoreAction;\n  isReady: Readable<boolean>;\n  data: Writable<OutputData>;\n};\n\nexport type SvelteEditorConfig = Omit<EditorConfig, 'holder' | 'holderId'>;\n\nexport function createEditor(\n  configuration: SvelteEditorConfig = {}\n): EditorResponse {\n  const initialData = configuration.data ?? {\n    time: new Date().getTime(),\n    blocks: [],\n  };\n  let editorInstance: EditorJS | undefined;\n  const { subscribe: subscribeEditor, set: setEditor } = writable<EditorStore>(\n    {}\n  );\n  const { subscribe: subscribeIsReady, set: setIsReady } = writable<boolean>(\n    false\n  );\n  const {\n    subscribe: subscribeData,\n    set: setData,\n    update: updateData,\n  } = writable<OutputData>(initialData);\n\n  let newSetData = (data: OutputData) => {\n    updateData((oldData) => ({ ...oldData, ...data }));\n    editorInstance?.render(data);\n  };\n\n  function editor(node: HTMLElement, parameters: SvelteEditorConfig = {}) {\n    async function setup() {\n      if (typeof window === 'undefined') return;\n      const Editor = await import('@editorjs/editorjs');\n      const instance = new Editor.default({\n        ...configuration,\n        ...parameters,\n        holder: node,\n      });\n\n      instance.isReady\n        .then(() => {\n          editorInstance = instance;\n          if (parameters.data) setData(parameters.data);\n\n          const save = async () => {\n            const data = await instance.save();\n            setData(data);\n          };\n\n          const clear = async () => {\n            instance.clear();\n            updateData((data) => ({\n              ...data,\n              time: new Date().getTime(),\n              blocks: [],\n            }));\n          };\n\n          const render = async (data: OutputData) => {\n            instance.render(data);\n          };\n\n          setEditor({\n            instance,\n            save,\n            render,\n            clear,\n          });\n          setIsReady(true);\n        })\n        .catch(console.error);\n    }\n    setup();\n    return {\n      destroy() {\n        editorInstance?.destroy();\n      },\n    };\n  }\n\n  editor.subscribe = subscribeEditor;\n\n  return {\n    editor,\n    isReady: { subscribe: subscribeIsReady },\n    data: { subscribe: subscribeData, set: newSetData, update: updateData },\n  };\n}\n"],"names":["noop","subscriber_queue","writable","value","start","stop","subscribers","Set","set","new_value","b","a","run_queue","length","subscriber","push","i","update","fn","subscribe","run","invalidate","add","size","delete","configuration","initialData","data","time","Date","getTime","blocks","editorInstance","subscribeEditor","setEditor","subscribeIsReady","setIsReady","subscribeData","setData","updateData","editor","node","parameters","async","window","instance","Promise","default","holder","isReady","then","save","render","clear","catch","console","error","setup","[object Object]","destroy","oldData"],"mappings":"aACO,SAASA,4DCQhB,MAAMC,EAAmB,GA0BlB,SAASC,EAASC,EAAOC,EAAQJ,GAEvC,IAAIK,EAEJ,MAAMC,EAAc,IAAIC,IAIxB,SAASC,EAAIC,GACZ,GDoBgCC,ECpBND,IDoBGE,ECpBVR,IDqBRQ,EAAID,GAAKA,EAAIC,IAAMD,GAAMC,GAAkB,iBAANA,GAAgC,mBAANA,KCpBzER,EAAQM,EACJJ,GAAM,CAET,MAAMO,GAAaX,EAAiBY,OACpC,IAAK,MAAMC,KAAcR,EACxBQ,EAAW,KACXb,EAAiBc,KAAKD,EAAYX,GAEnC,GAAIS,EAAW,CACd,IAAK,IAAII,EAAI,EAAGA,EAAIf,EAAiBY,OAAQG,GAAK,EACjDf,EAAiBe,GAAG,GAAGf,EAAiBe,EAAI,IAE7Cf,EAAiBY,OAAS,GDOxB,IAAwBF,EAAGD,ECGjC,SAASO,EAAOC,GACfV,EAAIU,EAAGf,IAwBR,MAAO,CAAEK,IAAAA,EAAKS,OAAAA,EAAQE,UAhBtB,SAAmBC,EAAKC,EAAarB,GAEpC,MAAMc,EAAa,CAACM,EAAKC,GAMzB,OALAf,EAAYgB,IAAIR,GACS,IAArBR,EAAYiB,OACflB,EAAOD,EAAMI,EAAKS,IAAWjB,GAE9BoB,EAAIjB,GACG,KACNG,EAAYkB,OAAOV,GACM,IAArBR,EAAYiB,MAAclB,IAC7BA,IACAA,EAAO,uCC3DToB,EAAoC,UAEpC,MAAMC,YAAcD,EAAcE,oBAAQ,CACxCC,MAAM,IAAIC,MAAOC,UACjBC,OAAQ,IAEV,IAAIC,EACJ,MAAQb,UAAWc,EAAiBzB,IAAK0B,GAAchC,EACrD,KAEMiB,UAAWgB,EAAkB3B,IAAK4B,GAAelC,GACvD,IAGAiB,UAAWkB,EACX7B,IAAK8B,EACLrB,OAAQsB,GACNrC,EAAqBwB,GAOzB,SAASc,EAAOC,EAAmBC,EAAiC,IA4ClE,OA3CAC,iBACE,GAAsB,oBAAXC,OAAwB,OACnC,MACMC,EAAW,WADIC,kDAAO,iEACAC,sDACvBtB,GACAiB,IACHM,OAAQP,KAGVI,EAASI,QACNC,MAAK,KACJlB,EAAiBa,EACbH,EAAWf,MAAMW,EAAQI,EAAWf,MAoBxCO,EAAU,CACRW,SAAAA,EACAM,KApBWR,UACX,MAAMhB,QAAakB,EAASM,OAC5Bb,EAAQX,IAmBRyB,OAPaT,MAAOhB,IACpBkB,EAASO,OAAOzB,IAOhB0B,MAjBYV,UACZE,EAASQ,QACTd,GAAYZ,kCACPA,IACHC,MAAM,IAAIC,MAAOC,UACjBC,OAAQ,UAcZK,GAAW,MAEZkB,MAAMC,QAAQC,OAEnBC,GACO,CACLC,UACE1B,MAAAA,GAAAA,EAAgB2B,YAOtB,OAFAnB,EAAOrB,UAAYc,EAEZ,CACLO,OAAAA,EACAS,QAAS,CAAE9B,UAAWgB,GACtBR,KAAM,CAAER,UAAWkB,EAAe7B,IA7DlBmB,IAChBY,GAAYqB,kCAAkBA,GAAYjC,KAC1CK,MAAAA,GAAAA,EAAgBoB,OAAOzB,IA2D4BV,OAAQsB"}